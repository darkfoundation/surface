<!DOCTYPE html>
<html>
    <head>
        <title>Surface Plotter</title>
        <script>const { PI, abs, ceil, floor, max, min, pow, random, round, sqrt, sin, cos, tan, log, exp } = Math;</script>
    </head>
    <body onload="getPlot();">
        <div style="width: 100%; text-align: center; font-family: verdana,sans-serif; font-size: 12px; white-space: nowrap">
            <label>function(x,y,r):&nbsp;<input type="text" id="plot" size=35 style="border: 1px solid #000; padding: 1px 5px;" value="z=0"></label>&nbsp;&nbsp;
            <label>render:&nbsp;<select id="wire" style="border: 1px solid #000">
                <option value="0">wireframe only</option>
                <option value="1">wireframe solid</option>
                <option value="2">surface</option>
            </select></label>&nbsp;&nbsp;
            <label>light&nbsp;from:&nbsp;<select id="lite" style="border: 1px solid #000">
                <option>left</option>
                <option>right</option>
            </select></label>&nbsp;&nbsp;
            <label>image&nbsp;size:&nbsp;<select id="pic" style="border: 1px solid #000">
                <option value="0">640x480</option>
                <option value="1">800x600</option>
                <option value="2">1024x768</option>
            </select></label>&nbsp;&nbsp;
            <input type="button" value="graph it!" style="border: 1px solid #000;" onclick="getPlot();"><br/>
            <canvas id="3d_plot" width="640" height="480"></canvas>
        </div>
        <script>
            const plotCanvas = document.getElementById("3d_plot");
            let errorHit = false;
            let f = 8;
            
            //set up functions
            function plot_z(x, y) {
                let r = Math.sqrt(x*x+y*y);
                try {
                    errorHit = false;
                    let result = eval(fn);
                } catch {
                    errorHit = true;
                } finally {
                    if (errorHit == false) {
                        return eval(fn);
                    }
                }
            }
    
            function u(x, y, wd) { 
                let sc = wd/640;
                return wd/2+x*sc-y*sc/2;
            }
    
            function v(x, y, ht) { 
                let sc = ht/480;
                return ht/2-plot_z(x, y)*sc-y*sc/2;
            }

            function getPlot() {
                fn = document.getElementById("plot").value;
                wire = document.getElementById("wire").value;
                switch(wire) {
                    case '0':
                    case '1':
                        f = 8;
                        break;
                    case '2':
                        f = 1;
                        break;
                }
                lite = (document.getElementById("lite").value == 'left')?(0):(1);
                pc = document.getElementById("pic").value;
                switch(pc) {
                    case '0':
                        plotCanvas.width = 640;
                        plotCanvas.height = 480;
                        break;
                    case '1':
                        plotCanvas.width = 800;
                        plotCanvas.height = 600;
                        break;
                    case '2':
                        plotCanvas.width = 1024;
                        plotCanvas.height = 768;
                        break;
                }

            //set up variables
                let o = (lite == 0)?(-.5):(.5);
                let p = (lite == 0)?(0):(-1);
                let q = 1;

                //set up canvas
                let wd = plotCanvas.clientWidth;
                let ht = plotCanvas.clientHeight;
                context = plotCanvas.getContext("2d");
                context.fillStyle = "black";
                context.fillRect(0, 0, wd, ht);

                //set up points
                let all_u = [];
                let all_v = [];
                let all_z = [];
                for (let x = 200; x >= -200; x-=f) {
                    let u_row = [];
                    let v_row = [];
                    let z_row = [];
                    for (let y = 200; y >= -200; y-=f) {
                        u_row.push(u(x, y, wd));
                        v_row.push(v(x, y, ht));
                        z_row.push(plot_z(x, y));
                    }
                    all_u.push(u_row);
                    all_v.push(v_row);
                    all_z.push(z_row);
                }

                context.font = "16px Monospace";
                context.textAlign = "center";
                context.fillStyle = "white";
                if (errorHit) {
                    context.fillText("FUNCTION ERROR!", wd/2, ht/2-5);
                } else {
                    cleanFn = fn.replace(/Math./g, "");
                    context.fillText(cleanFn, wd/2, ht-10);

                    //set up surfaces
                    let w = Math.sqrt(o*o+p*p+q*q);
                    let pal_all = [];
                    let k = f*f;
                    for (let x = 200; x > -200; x-=f) {
                        let pal_row = [];
                        let m = (200-x)/f;
                        for (let y = 200; y > -200; y-=f) {
                            let n = (200-y)/f;
                            let i = f*(all_z[m+1][n]-all_z[m][n]);
                            let j = f*(all_z[m][n+1]-all_z[m][n]);
                            let l = (i*o+j*p+k*q)/Math.sqrt(i*i+j*j+k*k)/w;
                            let c = (l >= 0)?(Math.round(253*l+1)):(1);
                            pal_row.push(c);
                        }
                        pal_all.push(pal_row);
                    }

                    //do plot
                    for (let t = 0; t < all_v.length-1; t++) {
                        for (let s = 0; s < all_u.length-1; s++) {
                            context.beginPath();
                            if (wire > 0) {
                                context.moveTo(all_u[s][t], all_v[s][t]);
                                context.lineTo(all_u[s][t+1], all_v[s][t+1]);
                                context.lineTo(all_u[s+1][t+1], all_v[s+1][t+1]);
                                context.lineTo(all_u[s+1][t], all_v[s+1][t]);
                                context.closePath();
                            } else {
                                context.moveTo(all_u[s+1][t], all_v[s+1][t]);
                                context.lineTo(all_u[s][t], all_v[s][t]);
                                context.lineTo(all_u[s][t+1], all_v[s][t+1]);
                                if (s == all_u.length-2) {
                                    context.moveTo(all_u[s+1][t], all_v[s+1][t]);
                                    context.lineTo(all_u[s+1][t+1], all_v[s+1][t+1]);
                                }
                            }
                            if (wire == 0 && t == all_v.length-2) {
                                context.moveTo(all_u[s][t+1], all_v[s][t+1]);
                                context.lineTo(all_u[s+1][t+1], all_v[s+1][t+1]);
                            }

                            let clr = 'rgb('+pal_all[s][t]+', '+pal_all[s][t]+', '+pal_all[s][t]+')';
                            context.strokeStyle = clr;
                            context.lineWidth = 1;
                            switch(wire) {
                                case '1':
                                    context.fillStyle = 'black';
                                    context.fill();
                                    break;
                                case '2':
                                    context.fillStyle = clr;
                                    context.fill();
                                    break;
                            }
                            context.stroke();
                        }
                    }
                }
            }
        </script>
    </body>
</html>